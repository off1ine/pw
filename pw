#!/bin/bash

#########################################################################
##  Welcome to the Automatic Password Creator!                         ##
##                                                                     ##
## In order to use this script, simply add a phrase after the 'pw'     ##
## command. For example:                                               ##
##                                                                     ##
##  pw mastodon                                                        ##
##                                                                     ##
## The script will then ask for a key. This can be any combination     ##
## of integers and should be at least 6 figures (in order to get a     ##
## sufficiently long password), for example:                           ##
##                                                                     ##
##  123456      (don't actually use that, though!)                     ##
##                                                                     ##
## If you don't give the phrase as an argument, we will ask for it.    ##
##                                                                     ##
## Password construction works as follows:                             ##
## - Cycle through characters in phrase.                               ##
## - Alternate between adding and subtracting the number values of key ##
## to/from phrase character values (a=1, b=2, etc.)                    ##
## - Turn result back into letter. 	                                   ##
## - Every second character is upper case.                             ##
## - After every second character, add sum of letter values of two     ##
## preceding characters.                                               ##
## - If sum is greater than 16, display as hex, otherwise display      ##
## cross sum as decimal.                                               ##
#########################################################################



##################
# We need some input, first. Phrase and Key, please! We will try to grab it from arguments.
##################

phrase=$1

##################
# If phrase is not used as argument, let's ask for it - and clean up our inputs. Lowercase only and no spaces!
##################

if [[ -z $phrase ]]; then
	echo
	echo "Phrase (letters only, please. Spaces are allowed but will be removed.):"
	read phrase
fi

phrase=${phrase,,}
phrase=${phrase//[[:space:]]/}

##################
# Exit if phrase contains numbers (currently not supported. Remove this when supported!)
##################

re='^[a-z]+$'
if ! [[ $phrase =~ $re ]] ; then
   echo "error: Please only use letters from a-z for your phrase." >&2; exit 1
fi

echo
echo "Key (numbers only, please.):"

read -s key
echo

key=${key//[[:space:]]/}

##################
# Exit if key contains letters
##################

re='^[0-9]+$'
if ! [[ $key =~ $re ]] ; then
   echo "error: Please only use integers from 0-9 for your key." >&2; exit 1
fi


##################
# Build two dictionaries, one for letters, one for numbers
##################

declare -A letters

letters[a]="1"
letters[b]="2"
letters[c]="3"
letters[d]="4"
letters[e]="5"
letters[f]="6"
letters[g]="7"
letters[h]="8"
letters[i]="9"
letters[j]="10"
letters[k]="11"
letters[l]="12"
letters[m]="13"
letters[n]="14"
letters[o]="15"
letters[p]="16"
letters[q]="17"
letters[r]="18"
letters[s]="19"
letters[t]="20"
letters[u]="21"
letters[v]="22"
letters[w]="23"
letters[x]="24"
letters[y]="25"
letters[z]="26"

declare -A numbers

numbers[1]="a"
numbers[2]="b"
numbers[3]="c"
numbers[4]="d"
numbers[5]="e"
numbers[6]="f"
numbers[7]="g"
numbers[8]="h"
numbers[9]="i"
numbers[10]="j"
numbers[11]="k"
numbers[12]="l"
numbers[13]="m"
numbers[14]="n"
numbers[15]="o"
numbers[16]="p"
numbers[17]="q"
numbers[18]="r"
numbers[19]="s"
numbers[20]="t"
numbers[21]="u"
numbers[22]="v"
numbers[23]="w"
numbers[24]="x"
numbers[25]="y"
numbers[26]="z"

##################
# Start with some basics - phrase and keys at i
# Include previous values for i mod 2 = 0 (we will need these later for some sums!)
##################


for ((i=1; i<=${#key}; i++))	
	do
##################	
# If key is longer than phrase, loop through phrase again
##################

		if [[ $i>${#phrase} ]]; then
			phrase_i=${phrase:$i-${#phrase}-1:1}

##################
# Check for i mod 2 and get previous values			
##################
			if [[ $i%2 -eq 0 ]]; then
				phrase_i_prev=${phrase:$i-${#phrase}-2:1}
			else
				phrase_i_prev=""
			fi
		else
			phrase_i=${phrase:$i-1:1};

##################
# Check for i mod 2 and get previous values
##################

	 		if [[ $i%2 -eq 0 ]]; then
	 			phrase_i_prev=${phrase:$i-2:1};
	 		else
	 			phrase_i_prev=""
	 		fi
	 	fi
	 		 	
 		key_i=${key:$i-1:1}

##################
# Check for i mod 2 and get previous values
##################
 		
 		if [[ $i%2 -eq 0 ]]; then
 			key_i_prev=${key:$i-2:1}
 		else
 			key_i_prev=""
 		fi
 								
##################
# Get letter value from phrase at i
# Get passphrase letter from addition/subtraction of key at i
##################
		
	 	phrase_num=${letters[$phrase_i]}
		pwd_num=$(($phrase_num+key_i))
		pwd_sum=""
		
##################		
# If pwd_num is greater than 26, count up from 1
# If it's less than zero, count back from 26
# If it's between 1 and 26, do nothing
##################		

		if [[ $pwd_num -gt 26 ]]; then
			pwd_num=$(($pwd_num-26))
		elif [[ $pwd_num -le 0 ]]; then
			pwd_num=$((26-($pwd_num*-1)))
		elif [[ $pwd_num -gt 0 ]] && [[ $pwd_num -le 26 ]]; then
			pwd_num=$pwd_num
		fi

##################		
# Check for i mod 2 and get previous values
##################

	 	pwd_num_prev=""

##################		
# If pwd_num_prev is greater than 26, count up from 1
# If it's less than zero, count back from 26
# If it's between 1 and 26, do nothing
##################
	 	
 		if [[ $i%2 -eq 0 ]]; then
 			phrase_num_prev=${letters[$phrase_i_prev]}
			pwd_num_prev=$(($phrase_num_prev+$key_i_prev))
			if [[ $pwd_num_prev -gt 26 ]]; then
				pwd_num_prev=$(($pwd_num_prev-26))
			elif [[ $pwd_num_prev -le 0 ]]; then
				pwd_num_prev=$((26-($pwd_num_prev*-1)))
			elif [[ $pwd_num_prev -gt 0 ]] && [[ $pwd_num_prev -le 26 ]]; then
				pwd_num_prev=$pwd_num_prev
			fi
			
			pwd_num=$(($phrase_num-$key_i))
		
			if [[ $pwd_num -gt 26 ]]; then
			pwd_num=$(($pwd_num-26))
		elif [[ $pwd_num -le 0 ]]; then
			pwd_num=$((26-($pwd_num*-1)))
		elif [[ $pwd_num -gt 0 ]] && [[ $pwd_num -le 26 ]]; then
			pwd_num=$pwd_num
		fi
		
##################		
# $pwd_sum is displayed after each to pwd characters, adding the values of the past two letters. 
##################
		
			pwd_sum=$(($pwd_num+$pwd_num_prev))
			
##################		
# If pwd_sum is greater than 16, display as hex value...
##################
			
			if [[ $pwd_sum -gt 16 ]]; then
				pwd_sum=$( printf '%x\n' $pwd_sum )
			else
			
##################		
# ...otherwise display cross sum
##################
				while [[ ${#pwd_sum}>1 ]]
				do
				pwd_sum=$(($(echo $pwd_sum | sed -e 's/\(.\)/\1\ +\ /g') 0))
				done
			fi
 		fi 				

################## 		
# Check for i mod 2 and get previous values. Display every second pwd_char as upper case.
##################

		if [[ $i%2 -eq 0 ]]; then
			pwd_char=$pwd_char${numbers[$pwd_num]^}$pwd_sum
		else
			pwd_char=$pwd_char${numbers[$pwd_num]}
		fi	
	done
	
##################	
# Add a little pizzazz with a "!"	
##################

echo Your passphrase is: $pwd_char"!"

secs=5
while [ $secs -gt 0 ]; do
   echo -ne "$secs\033[0K\r"
   sleep 1
   : $((secs--))
done

while [ $secs -eq 0 ]; do
	clear
done

